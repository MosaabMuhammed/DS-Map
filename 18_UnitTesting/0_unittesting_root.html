<!DOCTYPE HTML>
<html>

<head>
    <meta charset="utf-8" />
    <title>
        Unit Testing
    </title>

    <link rel="stylesheet" href="../prism.css">
</head>

<body>
    <div style="width:1000px;margin:auto;">

        <h1 id="1startercode">
            Unit Testing
        </h1>
        <details>
            <summary><b>Commands</b></summary>
            <pre class="language-python"><code>>> pytest</code></pre>
        </details><br>
        <details>
            <summary><b>Test simple function</b></summary>
            <h3>Main Code</h3>
            <pre class="language-python"><code>class Calculator:
"""A terrible calculator."""

def add(self, a, b):
    """Add two numbers."""
    return a + b</code></pre>
            <h3>Test Function</h3>
            <pre class="language-python"><code>from calculator import Calculator

def test_add():
    calculator = Calculator()

    result = calculator.add(2, 3)

    assert result == 5</code></pre>

        </details>
        <details>
            <summary><b>Test Exception</b></summary>
            <h3>Main Function</h3>
            <pre class="language-python"><code>class CalculatorError(Exception):
    """For calculator errors"""

    class Calculator:
        """A terrible calculator."""

        def divide(self, a, b):
            """Divide two numbers."""
            try:
                return a / b
            except ZeroDivisionError as ex:
                raise CalculatorError("You can't divide by zero.") from ex</code></pre>
            <h3>Test File</h3>
            <pre class="language-python"><code>def test_divide_by_zero():
calculator = Calculator()

with pytest.raises(CalculatorError):
    result = calculator.divide(9, 0)</code></pre>
        </details>

        <details>
            <summary><b>Test Custom Expection</b></summary>
            <pre class="language-python"><code>import numbers

class CalculatorError(Exception):
    """For calculator errors"""

class Calculator:
    """A terrible calculator."""

    def add(self, a, b):
        """Add two numbers."""
        self._check_operand(a)
        self._check_operand(b)
        return a + b

    def _check_operand(self, operand):
        """Check that the operand is a number."""
        if not isinstance(operand, numbers.Number):
            raise CalculatorError(f'"{operand}" is not a number.')
</code></pre>
            <pre class="language-python"><code>import pytest
from calculator import Calculator, CalculatorError

def test_add_weird_stuff():
    calculator = Calculator()

    with pytest.raises(CalculatorError):
        result = calculator.add("two", 3)</code></pre>
        </details>
        <details>
            <summary><b>Use Multiple Inputs for a single test function [paramatrize]</b></summary>
            <pre class="language-python"><code>import pytest

@pytest.mark.parametrize(
    "a, b, expected",
    [
        (1, 1, 2),
        (2, 1, 3),
        (3, 1, 3),
    ],
)

def  test_add_with_params(a, b, expected):
    assert calculator.add(a, b, expected)</code></pre>
        </details>
        <details>
            <summary><b>Grouping your tests inside a class</b></summary>
            <pre class="language-python"><code>class TestAdd:
    def test_add(self):
        assert calculator.add(1, 2) == 3

    def test_error(self):
        with pytest.raises(CalculatorError):
            calculator.add("two", 1)
            </code></pre>
        </details>
        <details>
            <summary><b>Fixtures</b></summary>
            <ul>
                <li>
                    <details>
                        <summary><b>Custom Fixture</b></summary>
                        <p>Fixtures used to be created to mimic a behaviour, so your tests won't depend on the real
                            behaviour to save time.</p>
                        <p>Create a file called conftest.py to write your fixtures, and your fixtures will be available for all tests in the folder.</p>
                        <pre class="language-python"><code># conftest.py
import pytest

@pytest.fixture
def my_fixture():
    return 42
</code></pre>
                        <pre class="language-python"><code># tests_file.py
def test_add(my_fixture):
    assert my_fixture == 42</code></pre>
                    </details>
                </li>
                <li>
                    <details>
                        <summary><b>Default Fixtures [capsys]</b></summary>
                        <pre class="language-python"><code>def test_capsys(capsys):
    print("hello")
    out, err = capsys.readouterr()
    assert "hello\n" == out
                </code></pre>
                    </details>
                </li>
                <li>
                    <details>
                        <summary><b>Default Fixtures [MonkeyPatch]</b></summary>
                        <a href="https://docs.pytest.org/en/7.1.x/how-to/monkeypatch.html">docs</a>
                        <pre class="language-python"><code>def test_monkeypatch(monkeypatch):
    def fake_add(a, b):
        return 42

    monkeypatch.setattr(demo, "add", fake_add)
    assert demo.add(2, 3) == 42</code></pre>
                    </details>
                </li>
                <li>
                    <details>
                        <summary><b>Default Fixtures [tmpdir]</b></summary>
                        <pre class="language-python"><code>def test_tmpdir(tmpdir):
    some_file = tmpdir.join("something.txt")
    some_file.write('{"hello": "world"}')

    result = demo.read_json(str(some_file))
    assert result["hello"] == "world"</code></pre>
                    </details>
                </li>
                <li>
                    <details>
                        <summary><b>Autouse Fixtures (fixtures you don’t have to request)</b></summary>
                        <p>Sometimes you may want to have a fixture (or even several) that you know all your tests will depend on. “Autouse” fixtures are a convenient way to make all tests automatically request them. This can cut out a lot of redundant requests, and can even provide more advanced fixture usage (more on that further down).
                        </p>
                        <pre class="language-python"><code># contents of test_append.py
import pytest


@pytest.fixture
def first_entry():
    return "a"


@pytest.fixture
def order(first_entry):
    return []


@pytest.fixture(autouse=True)
def append_first(order, first_entry):
    return order.append(first_entry)


def test_string_only(order, first_entry):
    assert order == [first_entry]


def test_string_and_int(order, first_entry):
    order.append(2)
    assert order == [first_entry, 2]</code></pre>
                    </details>
                </li>
            </ul>
        </details>
        <details>
            <summary><b>Mock</b></summary>
            <p>used to replicated third-party services and make the test independent of them.</p>
            <pre class="language-python"><code># forecaster.py

class Forecaster:
    def __init__(self, weather_service):
        self.weather_service = weather_service
    
    def forecast(self):
        reading = self.weather_service.barometer()
        forecasts = dict(
            rising="Going to rain",
            falling="Looks clear"
        )
        return forecasts[reading]
            </code></pre>
            <pre class="language-python"><code># test_forecaster.py
import pytest
from mock import Mock
from forecaster import Forecaster, WeatherService

@pytest.fixture
def mock_ws():
    return Mock(spec=WeatherService)

def test_rain_when_barometer_rising(mock_ws):
    forecaster = Forecaster(mock_ws)
    mock_ws.barometer.return_value == "rising"
    assert forecaster.forecast() == "Going to rain"</code></pre>
        </details>
    </div>
    <script src="../prism.js"></script>
</body>

</html>