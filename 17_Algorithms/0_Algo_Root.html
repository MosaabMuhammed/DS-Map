<!DOCTYPE HTML>
<html>

<head>
    <meta charset="utf-8" />
    <title>
        Data Structure & Algorithms
    </title>
    <link rel="stylesheet" href="../prism.css">
</head>

<body>
    <h1 style="color:darkcyan;text-decoration:underline">
        Data Structure & Algorithms
    </h1>
    <div style="width:1000px;margin:auto">
        <li><a href="./notebooks/Big-O Algorithm Complexity Cheat Sheet (Know Thy C 6d9f687da3714f30a1fbd1c58f77ec4a.html">Big O Notations for DS & Algorithms</a></li>

        <details>
            <summary><b>Array</b></summary>
            <details>
                <summary><b>Get Index (r, c) of 2D to 1D index, vice versa</b></summary>
                <pre class="language-python"><code># Assuming r = 1, c = 3 for 2D array
# How to get the corresponding index with these values.

idx = r * n_cols + c
arr1D[idx] == arr2D[r][c] # True

rr = idx / n_cols; cc = idx % n_cols
arr2D[rr][cc] == arr1D[idx] # True
                </code></pre>
            </details>
        <br></details>

        <details>            
            <summary><b>Linkedlist</b></summary>
            <details>
                <summary><b>Structure</b></summary>
                <pre class="language-python"><code>'''
* @file   DoublyLinkedList.py
* @author (original JAVA) William Fiset, william.alexandre.fiset@gmail.com
*         (conversion to Python) Armin Zare Zadeh, ali.a.zarezadeh@gmail.com
* @date   20 Jun 2020
* @version 0.1
* @brief   A doubly linked list implementation.
'''

import ctypes 


class Node(object):
    ''' 
    Internal node class to represent data
    '''
    def __init__(self, data, prev, next): 
    self.data = data
    self.prev = prev
    self.next = next


    def __repr__(self):
        return str(self.data)


class DoublyLinkedList(object): 
    ''' 
    DYNAMIC ARRAY CLASS (Similar to Python List) 
    '''
        
    def __init__(self): 
        self.llSize = 0 
        self.head = None
        self.tail = None
        self.travIter = None

    def __len__(self): 
        """ 
        Return number of elements sorted in array 
        """
        return self.llSize


    def clear(self):
        """ 
        Empty this linked list, O(n)
        """
        trav = self.head
        while trav is not None:
            next = trav.next
            trav.prev = trav.next = None
            trav.data = None
            trav = next

        self.head = None
        self.tail = None
        trav = None
        self.llSize = 0


    def size(self):
        """ 
        Return the size of this linked list
        """
        return self.llSize


    def isEmpty(self):
        """ 
        Is this linked list empty? 
        """
        return self.size() == 0


    def add(self, elem):
        """ 
        Add an element to the tail of the linked list, O(1)
        """
        self.addLast(elem)


    def addLast(self, elem):
        """ 
        Add a node to the tail of the linked list, O(1) 
        """
        if self.isEmpty():
            self.head = self.tail = Node(elem, None, None)
        else:
            self.tail.next = Node(elem, self.tail, None)
            self.tail = self.tail.next

        self.llSize += 1


    def addFirst(self, elem):
        """ 
        Add an element to the beginning of this linked list, O(1) 
        """
        if self.isEmpty():
            self.head = self.tail = Node(elem, None, None)
        else:
            self.head.prev = Node(elem, None, self.head)
            self.head = self.head.prev

        self.llSize += 1


    def addAt(self, index, data):
        """ 
        Add an element at a specified index
        """ 
        if index < 0:
            raise Exception('index should not be negative. The value of index was: {}'.format(index))

        if index == 0:
            self.addFirst(data)
            return

        if index == self.llSize:
            self.addLast(data)
            return

        temp = self.head
        for i in range(0, index - 1):
            temp = temp.next

        newNode = Node(data, temp, temp.next)
        temp.next.prev = newNode
        temp.next = newNode

        self.llSize += 1


    def peekFirst(self):
        """ 
        Check the value of the first node if it exists, O(1)
        """ 
        if self.isEmpty():
            raise Exception('Empty list')
        return self.head.data


    def peekLast(self):
        """ 
        Check the value of the last node if it exists, O(1)
        """ 
        if self.isEmpty():
            raise Exception('Empty list')
        return self.tail.data


    def removeFirst(self):
        """ 
        Remove the first value at the head of the linked list, O(1)
        """ 
        # Can't remove data from an empty list
        if self.isEmpty():
            raise Exception('Empty list')

        # Extract the data at the head and move
        # the head pointer forwards one node
        data = self.head.data
        self.head = self.head.next
        self.llSize -= 1

        # If the list is empty set the tail to null
        if self.isEmpty():
            self.tail = None

        # Do a memory cleanup of the previous node
        else:
            self.head.prev = None

        # Return the data that was at the first node we just removed
        return data


    def removeLast(self):
        """ 
        Remove the last value at the tail of the linked list, O(1)
        """ 
        # Can't remove data from an empty list
        if self.isEmpty():
            raise Exception('Empty list')

        # Extract the data at the tail and move
        # the tail pointer backwards one node
        data = self.tail.data
        self.tail = self.tail.prev
        self.llSize -= 1

        # If the list is now empty set the head to null
        if self.isEmpty():
            self.head = None

        # Do a memory clean of the node that was just removed
        else:
            self.tail.next = None

        # Return the data that was in the last node we just removed
        return data


    def __remove__(self, node):
        """ 
        Remove an arbitrary node from the linked list, O(1)
        """ 
        # If the node to remove is somewhere either at the
        # head or the tail handle those independently
        if node.prev == None:
            return self.removeFirst()
        if node.next == None:
            return self.removeLast()

        # Make the pointers of adjacent nodes skip over 'node'
        node.next.prev = node.prev;
        node.prev.next = node.next;

        # Temporarily store the data we want to return
        data = node.data

        # Memory cleanup
        node.data = None
        node.next = None
        node.prev = None
        node = None

        self.llSize -= 1

        # Return the data in the node we just removed
        return data


    def removeAt(self, index):
        """ 
        Remove a node at a particular index, O(n)
        """ 
        # Make sure the index provided is valid
        if index < 0 or index >= self.llSize:
            raise ValueError("wrong index")

        # Search from the front of the list
        if index < self.llSize / 2:
            i = 0
            trav = self.head
            while i != index:
            i += 1  
            trav = trav.next
            
        # Search from the back of the list
        else:
            i = self.llSize - 1
            trav = self.tail
            while i != index:
            i -= 1
            trav = trav.prev

        return self.__remove__(trav)


    def remove(self, obj):
        """ 
        Remove a particular value in the linked list, O(n)
        """ 
        trav = self.head

        # Support searching for null
        if obj is None:
            trav = self.head
            while trav is not None:
            if trav.data is None:
                self.__remove__(trav)
                return True

            trav = trav.next

        # Search for non null object
        else:
            trav = self.head

            while trav is not None:
            if obj == trav.data:
                self.__remove__(trav);
                return True
            
            trav = trav.next

        return False


    def indexOf(self, obj):
        """ 
        Find the index of a particular value in the linked list, O(n)
        """ 
        index = 0
        trav = self.head

        # Support searching for null
        if obj is None:
            while trav is not None:
            if trav.data is None:
                return index
            trav = trav.next
            index += 1
        # Search for non null object
        else:
            while trav is not None:
            if obj == trav.data:
                return index
            trav = trav.next
            index += 1      

        return -1


    def contains(self, obj):
        """ 
        Check if a value is contained within the linked list
        """ 
        return self.indexOf(obj) != -1


    def __iter__(self): 
        """
        Called when iteration is initialized
        """
        self.travIter = self.head
        return self


    def __next__(self): 
        """
        To move to next element. 
        """
        # Stop iteration if limit is reached 
        if self.travIter is None:
            raise StopIteration 

        # Store current travIter.data 
        data = self.travIter.data
        self.travIter = self.travIter.next

        # Else increment and return old value 
        return data


    def __repr__(self):
        sb = ""
        sb = sb + '[ '
        trav = self.head
        while trav is not None:
            sb = sb + str(trav.data)
            if trav.next is not None:
            sb = sb + ', '
            
            trav = trav.next

        sb = sb + ' ]'

    return str(sb)</code></pre>
            </details>
            <details>
                <summary><b>Traverse a linkedlist</b></summary>
                <details>
                    <summary><b>Iterative</b></summary>
                    <pre class="language-python"><code>def print_linkedlist(head: Node) -> None:
    current = head
    while current:
        print(current.val)
        current = current.next</code></pre>
                </details>
                <details>
                    <summary><b>Recursive</b></summary>
                    <pre class="language-python"><code>def print_linkedlist_rec(head: Node) -> None:
    if head is None:
        return
    print(head.val)
    return print_linkedlist_rec(head.next)</code></pre>
                </details>
            <br></details> 
            <details>
                <summary><b>To List</b></summary>
                <ul>
                <li><details>
                        <summary><b>Iterative</b></summary>
                        <pre class="language-python"><code>def tolist(head: Node) -> list:
    current = head
    vals = []
    while current:
        vals.append(current.val)
        current = current.next
    return vals</code></pre>
                    </details></li>
                    <li><details>
                    <summary><b>Recursive</b></summary>
                    <pre class="language-python"><code>def tolist_rec(head: Node) -> list:
    if not head:
        return []
    return [head.val] + tolist_rec(head.next)
    
def to_list_rec2(head: Node) -> list:
    def fill_values(node: None, values: list) -> None:
        if not node: return;
        values.append(node.val)
        fill_values(node.next, values)

    values = []
    fill_values(head, values)
    return values</code></pre>
                </details></li>
            </ul></details>
                <details>
                    <summary><b>Reverse</b></summary>
                    <ul>
                        <li><details>
                            <summary><b>Iterative</b></summary>
                            <pre class="language-python"><code>def reverse(head: Node) -> Node:
    prev, curr = None, head

    while curr:
        nxt = curr.next
        curr.next = prev
        prev = curr
        curr = nxt
    return prev</code></pre>
                        </details></li>
                        <li><details>
                            <summary><b>Recursive</b></summary>
                            <pre class="language-python"><code>def reverse_rec(curr: Node, prev=None) -> Node:
    if not curr: return prev
    nxt = curr.next
    curr.next = prev
    return reverse_rec(nxt, curr)

def reverse_rec2(head: Node) -> Node:
    if not head or not head.next: return head
    p = reverse_rec2(head.next)
    head.next.next = head
    head.next = None
    return p</code></pre>
                        </details></li>
                    </ul>
                </details>

                <details>
                    <summary><b>Sort</b></summary>
                    <pre class="language-python"><code># Using bubble Sort
# Sort the linked list
def sortLinkedList(self, head):
    current = head
    index = Node(None)

    if head is None:
        return
    else:
        while current is not None:
            # index points to the node next to current
            index = current.next

            while index is not None:
                if current.data > index.data:
                    current.data, index.data = index.data, current.data

                index = index.next
            current = current.next
                    </code></pre>
                </details>
        <br></details>

        <details>
            <summary><b>Union Find</b></summary>
            <h3>Normal Implementation</h3>
            <pre class="language-python"><code>class UF:
    def __init__(self, n):
        self.p = [i for i in range(n)]
        self.n = n
        self.size = n

    def union(self, i, j):
        pi, pj = self.find(i), self.find(j)
        if pi != pj:
            self.size -= 1
            self.p[pj] = pi

    def find(self, i):
        if i != self.p[i]:
            self.p[i] = self.find(self.p[i])
        return self.p[i]</code></pre>
            <h3>Optimized Disjoin Set (Union Find): Path Compression & Union by Rank</h3>
            <pre class="language-python"><code>class UnionFind(object):
    def __init__(self, grid):
        m, n = len(grid), len(grid[0])
        self.count = 0
        self.parent = [-1] * (m*n)
        self.rank = [0] * (m*n)
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    self.parent[i*n + j] = i*n + j
                    self.count += 1

    def find(self, i):
        if self.parent[i] != i:
            self.parent[i] = self.find(self.parent[i])
        return self.parent[i]

    def union(self, x, y):
        rootx = self.find(x)
        rooty = self.find(y)
        if rootx != rooty:
            if self.rank[rootx] > self.rank[rooty]:
                self.parent[rooty] = rootx
            elif self.rank[rootx] < self.rank[rooty]:
                self.parent[rootx] = rooty
            else:
                self.parent[rooty] = rootx
                self.rank[rootx] += 1
            self.count -= 1</code></pre>
        </details>

        <details>
            <summary>
                <b>
                    Search
                </b>
            </summary>
            <details>
                <summary>
                    <b>
                        Binary Search
                    </b>
                </summary>
                The list must be sorted before using Binary Search.
                <br />
                <details>
                    <summary>
                        Iterative
                    </summary>
                    <pre class="language-python"><code>
# It returns location of x in given array arr
# if present, else returns -1
def binarySearch(arr, l, r, x):
    while l &lt;= r:
        mid = l + (r - l) // 2;     
        # Check if x is present at mid
        if arr[mid] == x:
            return mid

        # If x is greater, ignore left half
        elif arr[mid] &lt; x:
            l = mid + 1

        # If x is smaller, ignore right half
        else:
            r = mid - 1

    # If we reach here, then the element
    # was not present
    return -1

# Driver Code
arr = [ 2, 3, 4, 10, 40 ]
x = 10

# Function call
result = binarySearch(arr, 0, len(arr)-1, x)

if result != -1:
    print ("Element is present at index % d" % result)
else:
    print ("Element is not present in array")
</code></pre>
                </details>
                <details>
                    <summary>
                        Recursive
                    </summary>
                    <pre class="language-python"><code># Returns index of x in arr if present, else -1
def binarySearch (arr, l, r, x):
    # Check base case
    if r &gt;= l:
        mid = l + (r - l) // 2

        # If element is present at the middle itself
        if arr[mid] == x:
            return mid

        # If element is smaller than mid, then it
        # can only be present in left subarray
        elif arr[mid] &gt; x:
            return binarySearch(arr, l, mid-1, x)

        # Else the element can only be present
        # in right subarray
        else:
            return binarySearch(arr, mid + 1, r, x)
    else:
        # Element is not present in the array
        return -1

# Driver Code
arr = [ 2, 3, 4, 10, 40 ]
x = 10
# Function call
result = binarySearch(arr, 0, len(arr)-1, x)

if result != -1:
    print ("Element is present at index % d" % result)
else:
    print ("Element is not present in array")
</code></pre>
                </details>
            </details>
            <br />
        </details>
        <details>
            <summary>
                <b>
                    Sort
                </b>
            </summary>
            <details>
                <summary>
                    <b>
                        Bubble Sort
                    </b>
                </summary>
                <p>Runtime: 0(n^2) average and worst case. Memory: 0(1) .</p>
                <p>ubble sort is used if <br>
                    complexity does not matter <br>
                    short and simple code is preferred</p>
                <pre class="language-python"><code>def bubbleSort(arr):
n = len(arr)
    # Traverse through all array elements
    for i in range(n-1):
    # range(n) also work but outer loop will repeat one time more than needed.
        # Last i elements are already in place
        for j in range(0, n-i-1):
            # traverse the array from 0 to n-i-1
            # Swap if the element found is greater
            # than the next element
            if arr[j] &gt; arr[j + 1] :
                arr[j], arr[j + 1] = arr[j + 1], arr[j]

# Driver code to test above
arr = [64, 34, 25, 12, 22, 11, 90]

bubbleSort(arr)
print ("Sorted array is:")
for i in range(len(arr)):
    print ("% d" % arr[i]), 
</code></pre>
<h2>Optimized Solution</h2>
<pre class="language-python"><code>def bubbleSort(arr):
    n = len(arr)
    # Traverse through all array elements
    for i in range(n-1):
    # range(n) also work but outer loop will repeat one time more than needed.
    # Last i elements are already in place
    # keep track of swapping
    swapped = False

        for j in range(0, n-i-1):
            # traverse the array from 0 to n-i-1
            # Swap if the element found is greater
            # than the next element
            if arr[j] &gt; arr[j + 1] :
                arr[j], arr[j + 1] = arr[j + 1], arr[j]

            swapped = True
    # no swapping means the array is already sorted
    # so no need for further comparison
    if not swapped:
        break
    
# Driver code to test above
arr = [64, 34, 25, 12, 22, 11, 90]

bubbleSort(arr)
print ("Sorted array is:")
for i in range(len(arr)):
    print ("% d" % arr[i]), 
    </code></pre>
            </details>

            <details>
                <summary><b>Selection Sort</b></summary>
                <p>Selection sort is a sorting algorithm that selects the smallest element from an unsorted list in each iteration and places that element at the beginning of the unsorted list.</p>
                <p>Runtime: O(n**2), Space: O(1)</p>
                <p>
                    The selection sort is used when
                    <ul>
                        <li>a small list is to be sorted</li>
                        <li>cost of swapping does not matter</li>
                        <li>checking of all the elements is compulsory</li>
                        <li>cost of writing to a memory matters like in flash memory (number of writes/swaps is O(n) as compared to O(n2) of bubble sort)</li>
                    </ul>
                </p>
                <pre class="language-python"><code>def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[min_idx], arr[i] = arr[i], arr[min_idx]</code></pre>
            </details>
            <details>
                <summary>
                    <b>
                        Insertion Sort
                    </b>
                </summary>
                <p>Runtime: 0(n^2) average and worst case. Memory: 0(1)</p>
                <p>
                    The insertion sort is used when:
                    <ul>
                        <li>the array is has a small number of elements</li>
                        <li>there are only a few elements left to be sorted</li>
                    </ul>
                </p>
                <pre class="language-python"><code># Function to do insertion sort
def insertionSort(arr):
    # Traverse through 1 to len(arr)
    for i in range(1, len(arr)):
        key = arr[i]
        # Move elements of arr[0..i-1], that are
        # greater than key, to one position ahead
        # of their current position
        j = i-1
        while j &gt;=0 and key &lt; arr[j] :
                arr[j+1] = arr[j]
                j -= 1
        arr[j+1] = key

# Driver code to test above
arr = [12, 11, 13, 5, 6]
insertionSort(arr)
print ("Sorted array is:")
for i in range(len(arr)):
    print ("%d" %arr[i])</code></pre>
            </details>
            <details>
                <summary>
                    <b>
                        Merge Sort
                    </b>
                </summary>
                <p>Runtime: 0(n log(n)) average and worst case. Memory: Depends</p>
                <pre class="language-python"><code>def mergeSort(arr):
    if len(arr) &gt; 1:
         # Finding the mid of the array
        mid = len(arr)//2
        # Dividing the array elements
        L = arr[:mid]
        # into 2 halves
        R = arr[mid:]
        # Sorting the first half
        mergeSort(L)
        # Sorting the second half
        mergeSort(R)
        i = j = k = 0

        # Copy data to temp arrays L[] and R[]
        while i &lt; len(L) and j &lt; len(R):
            if L[i] &lt; R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1

        # Checking if any element was left
        while i &lt; len(L):
            arr[k] = L[i]
            i += 1
            k += 1

        while j &lt; len(R):
            arr[k] = R[j]
            j += 1
            k += 1</code></pre>
                <pre class="language-python"><code>from collections import deque

def MergeSort(arr):
    if len(arr) == 1: return deque(arr)
    a = MergeSort(arr[:len(arr)//2])
    b = MergeSort(arr[len(arr)//2:])

    res = deque()
    while a and b:
        if a[0] &lt;= b[0]:
            res.append(a.popleft())
        else:
            res.append(b.popleft())
    res += a
    res += b
    return res
</code></pre>
            </details>
            <details>
                <summary>
                    <b>
                        Quick Sort
                    </b>
                </summary>
                <p>Runtime: O(n log(n)) average, O(n^2 ) worst case. Memory: 0(log(n))</p>
                <details>
                    <summary><b>Code 1</b></summary>
                    <pre class="language-python"><code># Python program for implementation of Quicksort Sort

# This function takes last element as pivot, places
# the pivot element at its correct position in sorted
# array, and places all smaller (smaller than pivot)
# to left of pivot and all greater elements to right
# of pivot
def partition(arr, low, high):
    i = (low-1)         # index of smaller element
    pivot = arr[high]     # pivot
    for j in range(low, high):
        # If current element is smaller than or
        # equal to pivot
        if arr[j] &lt;= pivot:
            # increment index of smaller element
            i = i+1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return (i+1)

# The main function that implements QuickSort
# arr[] --&gt; Array to be sorted,
# low  --&gt; Starting index,
# high  --&gt; Ending index

# Function to do Quick sort
def quickSort(arr, low, high):
    if len(arr) == 1:
        return arr
    if low &lt; high:
        # pi is partitioning index, arr[p] is now
        # at right place
        pi = partition(arr, low, high)
        # Separately sort elements before
        # partition and after partition
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)
                        </code></pre>
                </details>
  
<details>
    <summary><b>Code 2</b></summary>
    <pre class="language-python"><code>def quicksort(array: list, left: int, right: int):
    index = partition(array, left, right)

    # sort the left half
    if (left < index - 1):
        quicksort(array, left, index-1)

    if (index < right):
        quicksort(array, index, right)

def partition(array: list, left: int, right: int):
    pivot = array[(left + right) // 2] # pick pivot point.
    while (left <= right):
        # find element on left that should be on right.
        while (array[left] < pivot):
            left += 1

        # Find element on right that should be on left.
        while (array[right] > pivot):
            right -= 1

        # Swap elements, and move left and right indices.
        if (left <= right):
            array[left], array[right] = array[right], array[left]
            left += 1
            right -= 1
    return left

l = [3, 4, 5, 1, 23, 34]
quicksort(l, 0, len(l)-1)
print(l)</code></pre>
</details>
            </details>
            <details>
                <summary><b>Counting Sort</b></summary>
                <p>Runtime: O(n+k), Space: O(max)</p>
                <pre class="language-python"><code>def counting_sort(arr):
    n = len(arr)
    output = [0]*n
    max_ = max(arr)

    # Initialize count array
    count = [0]*(max_+1)
    for i in range(n):
        count[arr[i]] += 1

    for i in range(1, max_+1):
        count[i] += count[i-1]

    i = n-1
    while i >= 0:
        output[count[arr[i]] - 1] = arr[i]
        count[arr[i]] -= 1
        i -= 1

    for i in range(n):
        arr[i] = output[i]


data = [4, 2, 2, 8, 3, 3, 1, 10, 20, 30, 40, 40, 50, 50, 100]
counting_sort(data)
print("Sorted Array in Ascending Order: ")
print(data)</code></pre>
            </details>

            <details>
                <summary><b>Radix sort</b></summary>
                <p>Radix sort is a sorting algorithm for integers (and some other data types) that takes advantage of the fact that integers have a finite number of bits. In radix sort, we iterate through each digit of the number, grouping numbers by each digit. For example, if we have an array of integers, we might first sort by the first digit, so that the Os are grouped together. Then, we sort each of these groupings by the next digit. We repeat this process sorting by each subsequent digit, until finally the whole array is sorted.</p>
                <pre class="language-python"><code># Radix sort in Python

# Using counting sort to sort the elements in the basis of significant places
def countingSort(array, place):
    size = len(array)
    output = [0] * size
    count = [0] * 10

    # Calculate count of elements
    for i in range(0, size):
        index = array[i] // place
        count[index % 10] += 1

    # Calculate cumulative count
    for i in range(1, 10):
        count[i] += count[i - 1]

    # Place the elements in sorted order
    i = size - 1
    while i >= 0:
        index = array[i] // place
        output[count[index % 10] - 1] = array[i]
        count[index % 10] -= 1
        i -= 1

    for i in range(0, size):
        array[i] = output[i]


# Main function to implement radix sort
def radixSort(array):
    # Get maximum element
    max_element = max(array)

    # Apply counting sort to sort elements based on place value.
    place = 1
    while max_element // place > 0:
        countingSort(array, place)
        place *= 10


data = [121, 432, 564, 23, 1, 45, 788]
radixSort(data)
print(data)</code></pre>
            </details>

            <details>
                <summary><b>Heap Sort</b></summary>
                <pre class="language-python"><code># Heap Sort in python
def heapify(arr, n, i):
    # Find largest among root and children
    largest = i
    l = 2 * i + 1
    r = 2 * i + 2

    if l < n and arr[i] < arr[l]:
        largest = l

    if r < n and arr[largest] < arr[r]:
        largest = r

    # If root is not largest, swap with largest and continue heapifying
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)


def heapSort(arr):
    n = len(arr)

    # Build max heap
    for i in range(n//2, -1, -1):
        heapify(arr, n, i)

    for i in range(n-1, 0, -1):
        # Swap
        arr[i], arr[0] = arr[0], arr[i]

        # Heapify root element
        heapify(arr, i, 0)


arr = [1, 12, 9, 5, 6, 10]
heapSort(arr)
n = len(arr)
print("Sorted array is")
for i in range(n):
    print("%d " % arr[i], end='')</code></pre>
            </details>

            <details>
                <summary><b>Shell Sort</b></summary>
                <pre class="language-python"><code>def shell_sort(arr, n):
    interval = n // 2
    while interval:
        for i in range(interval, n):
            tmp = arr[i]
            j = i
            while j >= interval and arr[j - interval] > tmp:
                arr[j] = arr[j - interval]
                j -= interval
            arr[j] = tmp
        interval //= 2

data = [9, 8, 3, 7, 5, 6, 4, 1]
size = len(data)
shell_sort(data, size)
print('Sorted Array in Ascending Order:')
print(data)</code></pre>
            </details>

            <details>
                <summary>
                    <b>
                        Topological Sorting
                    </b>
                </summary>
                <pre class="language-python"><code># Python program to print topological sorting of a DAG
from collections import defaultdict

# Class to represent a graph
class Graph:
    def __init__(self, vertices):
        self.graph = defaultdict(list)  # dictionary containing adjacency List
        self.V = vertices  # No. of vertices

    # function to add an edge to graph
    def addEdge(self, u, v):
        self.graph[u].append(v)

    # A recursive function used by topologicalSort
    def topologicalSortUtil(self, v, visited, stack):

        # Mark the current node as visited.
        visited[v] = True

        # Recur for all the vertices adjacent to this vertex
        for i in self.graph[v]:
            if visited[i] == False:
                self.topologicalSortUtil(i, visited, stack)

        # Push current vertex to stack which stores result
        stack.append(v)

    # The function to do Topological Sort. It uses recursive
    # topologicalSortUtil()
    def topologicalSort(self):
        # Mark all the vertices as not visited
        visited = [False]*self.V
        stack = []
        # Call the recursive helper function to store Topological
        # Sort starting from all vertices one by one
        for i in range(self.V):
            if visited[i] == False:
                self.topologicalSortUtil(i, visited, stack)

        # Print contents of the stack
        print(stack[::-1])  # return list in reverse order


# Driver Code
g = Graph(6)
g.addEdge(5, 2)
g.addEdge(5, 0)
g.addEdge(4, 0)
g.addEdge(4, 1)
g.addEdge(2, 3)
g.addEdge(3, 1)

print ("Following is a Topological Sort of the given graph")

# Function Call
g.topologicalSort()
</code></pre>
            </details>
        <br></details>

        <details>
            <summary><b>Backtracking</b></summary>
            <details>
                <summary><b>Template</b></summary>
                <pre class="language-python"><code>def is_valid_state(state):
    # check if it is a valid solution
    return True

def get_candidates(state):
    return []

def search(state, solutions):
    if is_valid_state(state):
        solutions.append(state.copy())
        # return

    for candidate in get_candidates(state):
        state.add(candidate)
        search(state, solutions)
        state.remove(candidate)

def solve():
    solutions = []
    state = set()
    search(state, solutions)
    return solutions</code></pre>
            </details>
            <details>
                <summary><b>n-queens</b></summary>
                <pre class="language-python"><code>class Solution:
    """
    example on the left: [1, 3, 0, 2]
    example on the right: [2, 0, 3, 1]
    """
    def solveNQueens(self, n: int) -> List[List[str]]:
        solutions = []
        state = []
        self.search(state, solutions, n)
        return solutions
        
    def is_valid_state(self, state, n):
        # check if it is a valid solution
        return len(state) == n

    def get_candidates(self, state, n):
        if not state:
            return range(n)
        
        # find the next position in the state to populate
        position = len(state)
        candidates = set(range(n))
        # prune down candidates that place the queen into attacks
        for row, col in enumerate(state):
            # discard the column index if it's occupied by a queen
            candidates.discard(col)
            dist = position - row
            # discard diagonals
            candidates.discard(col + dist)
            candidates.discard(col - dist)
        return candidates

    def search(self, state, solutions, n):
        if self.is_valid_state(state, n):
            state_string = self.state_to_string(state, n)
            solutions.append(state_string)
            return

        for candidate in self.get_candidates(state, n):
            # recurse
            state.append(candidate)
            self.search(state, solutions, n)
            state.pop()

    def state_to_string(self, state, n):
        # ex. [1, 3, 0, 2]
        # output: [".Q..","...Q","Q...","..Q."]
        ret = []
        for i in state:
            string = '.' * i + 'Q' + '.' * (n - i - 1)
            ret.append(string)
        return ret</code></pre>
            </details>
        <br> </details>

        <details>
            <summary><b>Tree</b></summary>
            <details>
                <summary><b>Traversal Template</b></summary>
            <pre class="language-python"><code># DFS
def preorder(self, root):
    if not root:
        return []
    ret = []
    stack = [root]
    while stack:
        node = stack.pop()
        ret.append(node.val)
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
    return ret

def postorder(self, root):
    if not root:
        return []
    from collections import deque
    ret = deque()
    stack = [root]
    while stack:
        node = stack.pop()
        ret.appendleft(node.val)
        if node.left:
            stack.append(node.left)
        if node.right:
            stack.append(node.right)
    return ret

def inorder(self, root):
    if not root:
        return []
    ret = []
    stack = []
    while root is not None or stack:
        while root is not None:
            stack.append(root)
            root = root.left
        root = stack.pop()
        ret.append(root.val)
        root = root.right
    return ret

# BFS
def levelorder(self, root):
    if not root:
        return []
    ret = []
    from collections import deque
    queue = deque([root])
    while queue:
        ret_row = []
        # fixed size for current level
        for _ in range(len(queue)):
            node = queue.popleft()
            ret_row.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        ret.append(ret_row)
    return ret</code></pre>
            </details>
        </details>
        <details>
            <summary>
                <b>
                    Graph
                </b>
            </summary>
            <details>
                <summary><b>Traversal Template</b></summary>
                <pre class="language-python"><code># Iterative
def dfs(graph, start):
  visited, stack = set(), [start]
  while stack:
    node = stack.pop()
    visited.add(node)
    for neighbor in graph[node]:
      if not neighbor in visited:
        stack.append(neighbor)
  return visited

# Return path
def dfs_path(graph, src, dst):
  stack = [(src, [src])]
  visited = set()
  while stack:
    node, path = stack.pop()
    if node in visited:
      continue
    if node == dst:
      return path
    visited.add(node)
    for neighbor in graph[node]:
      stack.append((neighbor, path + [neighbor]))
  return None

# Recursive
def dfs(graph, start):
  def dfs_recursive(graph, start, visited):
    visited.add(start)
    for neighbor in graph[start]:
      if not neighbor in visited:
        dfs_recursive(graph, neighbor, visited)
  visited = set()
  return dfs_recursive(graph, start, visited)

def bfs(graph, start):
  visited, queue = set(), deque([start])
  while queue:
    node = queue.popleft()
    visited.add(node)
    for neighbor in graph[node]:
      if not neighbor in visited:
          queue.append(neighbor)
  return visited

# Return path
def bfs_path(graph, src, dst):
  visited, queue = set(), deque([[src]])
  while queue:
    path = queue.popleft()
    node = path[-1]
    if node in visited:
      continue
    if node == dst:
      return path
    for neighbor in graph[node]:
      queue.append(path + [neighbor])
  return None

# Topological sort
# Current node comes before any of its neighbor
def top_sort(graph):
  def dfs_recursive(graph, start, visited, sorted_nodes)
    visited.add(start)
    for neighbor in graph[start]:
      if not neighbor in visited:
        dfs_recursive(graph, neighbor, visited)
    sorted_nodes.appendleft(start)

  sorted_nodes, visited = deque(), set()
  for node in graph:
    dfs_recursive(graph, node, visited, sorted_nodes)
  return sorted_nodes
                </code></pre>
            </details>
            <details>
                <summary>
                    <b>
                        Depth-First Search
                    </b>
                </summary>
                <details>
                    <summary>
                        Recursive
                    </summary>
                    <pre class="language-python"><code>from collections import defaultdict

class Graph:
    def __init__(self):
            self.graph = defaultdict(list)

    def addEdge(self, u, v):
        self.graph[u].append(v)

    def DFSUtil(self, v, visited):
        visited.add(v)
        print(v, end=' ')

        for neighbour in self.graph[v]:
            if neighbour not in visited:
                self.DFSUtil(neighbour, visited)

    def DFS(self, v):
        visited = set()
        self.DFSUtil(v, visited)

g = Graph()
g.addEdge(0, 1)
g.addEdge(0, 2)
g.addEdge(1, 2)
g.addEdge(2, 0)
g.addEdge(2, 3)
g.addEdge(3, 3)

print("Following is DFS from (Starting from vertex 2)")
g.DFS(2)
</code></pre>
                </details>
                <details>
                    <summary>
                        Iterative [Stack]
                    </summary>
                    <pre class="language-python"><code># This class represents a directed graph using adjacency
# list representation
class Graph:
    def __init__(self,V): # Constructor
        self.V = V        # No. of vertices
        self.adj  = [[] for i in range(V)]  # adjacency lists

    def addEdge(self,v, w):     # to add an edge to graph
        self.adj[v].append(w)    # Add w to vâ€™s list.

    # prints all not yet visited vertices reachable from s
    def DFS(self,s):            # prints all vertices in DFS manner from a given source.
                                # Initially mark all verices as not visited
        visited = [False for i in range(self.V)]

        # Create a stack for DFS
        stack = []

        # Push the current source node.
        stack.append(s)

        while (len(stack)):
            # Pop a vertex from stack and print it
            s = stack[-1]
            stack.pop()

            # Stack may contain same vertex twice. So
            # we need to print the popped item only
            # if it is not visited.
            if (not visited[s]):
                print(s,end=' ')
                visited[s] = True

            # Get all adjacent vertices of the popped vertex s
            # If a adjacent has not been visited, then push it
            # to the stack.
            for node in self.adj[s]:
                if (not visited[node]):
                    stack.append(node)



# Driver program to test methods of graph class

g = Graph(5); # Total 5 vertices in graph
g.addEdge(1, 0);
g.addEdge(0, 2);
g.addEdge(2, 1);
g.addEdge(0, 3);
g.addEdge(1, 4);

print("Following is Depth First Traversal")
g.DFS(0)
</code></pre>
                </details>
            </details>
            <details>
                <summary>
                    <b>
                        Beadth-First Search
                    </b>
                </summary>
                <pre class="language-python"><code>from collections import defaultdict
class Graph
    # Constructor
    def __init__(self)
        # default dictionary to store graph
        self.graph = defaultdict(list)

    # function to add an edge to graph
    def addEdge(self,u,v):
        self.graph[u].append(v)

    # Function to print a BFS of graph
    def BFS(self, s):
        # Mark all the vertices as not visited
        visited = [False] * (max(self.graph) + 1)

        # Create a queue for BFS
        queue = []

        # Mark the source node as
        # visited and enqueue it
        queue.append(s)
        visited[s] = True

        while queue:

            # Dequeue a vertex from
            # queue and print it
            s = queue.pop(0)
            print (s, end = " ")

            # Get all adjacent vertices of the
            # dequeued vertex s. If a adjacent
            # has not been visited, then mark it
            # visited and enqueue it
            for i in self.graph[s]:
                if visited[i] == False:
                    queue.append(i)
                    visited[i] = True

# Create a graph given in
# the above diagram
g = Graph()
g.addEdge(0, 1)
g.addEdge(0, 2)
g.addEdge(1, 2)
g.addEdge(2, 0)
g.addEdge(2, 3)
g.addEdge(3, 3)

print ("Following is Breadth First Traversal"
                  " (starting from vertex 2)")
g.BFS(2)
</code></pre>
            </details>

            <details>
                <summary><b>Find Shortest Path</b></summary>
                <ul>
                <li><details>
                    <summary><b>Bell-Ford Algorithm</b></summary>
                    <pre class="language-python"><code># Bellman Ford Algorithm in Python
class Graph:

    def __init__(self, vertices):
        self.V = vertices   # Total number of vertices in the graph
        self.graph = []     # Array of edges

    # Add edges
    def add_edge(self, s, d, w):
        self.graph.append([s, d, w])

    # Print the solution
    def print_solution(self, dist):
        print("Vertex Distance from Source")
        for i in range(self.V):
            print("{0}\t\t{1}".format(i, dist[i]))

    def bellman_ford(self, src):

        # Step 1: fill the distance array and predecessor array
        dist = [float("Inf")] * self.V
        # Mark the source vertex
        dist[src] = 0

        # Step 2: relax edges |V| - 1 times
        for _ in range(self.V - 1):
            for s, d, w in self.graph:
                if dist[s] != float("Inf") and dist[s] + w < dist[d]:
                    dist[d] = dist[s] + w

        # Step 3: detect negative cycle
        # if value changes then we have a negative cycle in the graph
        # and we cannot find the shortest distances
        for s, d, w in self.graph:
            if dist[s] != float("Inf") and dist[s] + w < dist[d]:
                print("Graph contains negative weight cycle")
                return

        # No negative weight cycle found!
        # Print the distance and predecessor array
        self.print_solution(dist)


g = Graph(5)
g.add_edge(0, 1, 5)
g.add_edge(0, 2, 4)
g.add_edge(1, 3, 3)
g.add_edge(2, 1, 6)
g.add_edge(3, 2, 2)

g.bellman_ford(0)</code></pre>
                </details></li>
            <br></details>
            </ul>
            <details>
                <summary>
                    <b>
                        Strongly Connected Components (SCC) - Kosaraju's algorithm
                    </b>
                </summary>
                <pre class="language-python"><code># Kosaraju's algorithm to find strongly connected components in Python

from collections import defaultdict
class Graph:
    def __init__(self, vertex):
        self.V = vertex
        self.graph = defaultdict(list)

    # Add edge into the graph
    def add_edge(self, s, d):
        self.graph[s].append(d)

    # dfs
    def dfs(self, d, visited_vertex):
        visited_vertex[d] = True
        print(d, end='')
        for i in self.graph[d]:
            if not visited_vertex[i]:
                self.dfs(i, visited_vertex)

    def fill_order(self, d, visited_vertex, stack):
        visited_vertex[d] = True
        for i in self.graph[d]:
            if not visited_vertex[i]:
                self.fill_order(i, visited_vertex, stack)
        stack = stack.append(d)

    # transpose the matrix
    def transpose(self):
        g = Graph(self.V)

        for i in self.graph:
            for j in self.graph[i]:
                g.add_edge(j, i)
        return g

    # Print stongly connected components
    def print_scc(self):
        stack = []
        visited_vertex = [False] * (self.V)

        for i in range(self.V):
            if not visited_vertex[i]:
                self.fill_order(i, visited_vertex, stack)

        gr = self.transpose()

        visited_vertex = [False] * (self.V)

        while stack:
            i = stack.pop()
            if not visited_vertex[i]:
                gr.dfs(i, visited_vertex)
                print("")


g = Graph(8)
g.add_edge(0, 1)
g.add_edge(1, 2)
g.add_edge(2, 3)
g.add_edge(2, 4)
g.add_edge(3, 0)
g.add_edge(4, 5)
g.add_edge(5, 6)
g.add_edge(6, 4)
g.add_edge(6, 7)

print("Strongly Connected Components:")
g.print_scc()
</code></pre>
            </details>
        <br></details>

        <details>
            <summary><b>AVL Tree</b></summary>
            <pre class="language-python"><code># AVL tree implementation in Python


import sys

# Create a tree node
class TreeNode(object):
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.height = 1


class AVLTree(object):

    # Function to insert a node
    def insert_node(self, root, key):

        # Find the correct location and insert the node
        if not root:
            return TreeNode(key)
        elif key < root.key:
            root.left = self.insert_node(root.left, key)
        else:
            root.right = self.insert_node(root.right, key)

        root.height = 1 + max(self.getHeight(root.left),
                                self.getHeight(root.right))

        # Update the balance factor and balance the tree
        balanceFactor = self.getBalance(root)
        if balanceFactor > 1:
            if key < root.left.key:
                return self.rightRotate(root)
            else:
                root.left = self.leftRotate(root.left)
                return self.rightRotate(root)

        if balanceFactor < -1:
            if key > root.right.key:
                return self.leftRotate(root)
            else:
                root.right = self.rightRotate(root.right)
                return self.leftRotate(root)

        return root

    # Function to delete a node
    def delete_node(self, root, key):

        # Find the node to be deleted and remove it
        if not root:
            return root
        elif key < root.key:
            root.left = self.delete_node(root.left, key)
        elif key > root.key:
            root.right = self.delete_node(root.right, key)
        else:
            if root.left is None:
                temp = root.right
                root = None
                return temp
            elif root.right is None:
                temp = root.left
                root = None
                return temp
            temp = self.getMinValueNode(root.right)
            root.key = temp.key
            root.right = self.delete_node(root.right,
                                            temp.key)
        if root is None:
            return root

        # Update the balance factor of nodes
        root.height = 1 + max(self.getHeight(root.left),
                                self.getHeight(root.right))

        balanceFactor = self.getBalance(root)

        # Balance the tree
        if balanceFactor > 1:
            if self.getBalance(root.left) >= 0:
                return self.rightRotate(root)
            else:
                root.left = self.leftRotate(root.left)
                return self.rightRotate(root)
        if balanceFactor < -1:
            if self.getBalance(root.right) <= 0:
                return self.leftRotate(root)
            else:
                root.right = self.rightRotate(root.right)
                return self.leftRotate(root)
        return root

    # Function to perform left rotation
    def leftRotate(self, z):
        y = z.right
        T2 = y.left
        y.left = z
        z.right = T2
        z.height = 1 + max(self.getHeight(z.left),
                            self.getHeight(z.right))
        y.height = 1 + max(self.getHeight(y.left),
                            self.getHeight(y.right))
        return y

    # Function to perform right rotation
    def rightRotate(self, z):
        y = z.left
        T3 = y.right
        y.right = z
        z.left = T3
        z.height = 1 + max(self.getHeight(z.left),
                            self.getHeight(z.right))
        y.height = 1 + max(self.getHeight(y.left),
                            self.getHeight(y.right))
        return y

    # Get the height of the node
    def getHeight(self, root):
        if not root:
            return 0
        return root.height

    # Get balance factore of the node
    def getBalance(self, root):
        if not root:
            return 0
        return self.getHeight(root.left) - self.getHeight(root.right)

    def getMinValueNode(self, root):
        if root is None or root.left is None:
            return root
        return self.getMinValueNode(root.left)

    def preOrder(self, root):
        if not root:
            return
        print("{0} ".format(root.key), end="")
        self.preOrder(root.left)
        self.preOrder(root.right)

    # Print the tree
    def printHelper(self, currPtr, indent, last):
        if currPtr != None:
            sys.stdout.write(indent)
            if last:
                sys.stdout.write("R----")
                indent += "     "
            else:
                sys.stdout.write("L----")
                indent += "|    "
            print(currPtr.key)
            self.printHelper(currPtr.left, indent, False)
            self.printHelper(currPtr.right, indent, True)


myTree = AVLTree()
root = None
nums = [33, 13, 52, 9, 21, 61, 8, 11]
for num in nums:
    root = myTree.insert_node(root, num)
myTree.printHelper(root, "", True)
key = 13
root = myTree.delete_node(root, key)
print("After Deletion: ")
myTree.printHelper(root, "", True)</code></pre>
        </details>

        <details>
            <summary>
                <b>
                    String
                </b>
            </summary>
            <details>
                <summary>
                    <b>
                        Largest Common Substring b/w 2 strings
                    </b>
                </summary>
                <h3>
                    Dynamic Programming
                </h3>
                <pre class="language-python"><code>def lcs(a, b):
    lengths = [[0 for j in range(len(b)+1)] for i in range(len(a)+1)]
    # row 0 and column 0 are initialized to 0 already
    for i, x in enumerate(a):
        for j, y in enumerate(b):
            if x == y:
                lengths[i+1][j+1] = lengths[i][j] + 1
            else:
                lengths[i+1][j+1] = \
                    max(lengths[i+1][j], lengths[i][j+1])
    return lengths[len(a)][len(b)]

</code></pre>
            </details>
        </details>
    </div>
    <script src="../prism.js"></script>
</body>

</html>